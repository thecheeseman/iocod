#!/usr/bin/env python3
# SPDX-FileCopyrightText: 2007 TTimo
# SPDX-FileCopyrightText: 2023 thecheeseman
#
# SPDX-License-Identifier: GPL-3.0-or-later
# SPDX-License-Identifier: GPL-3.0-or-later

# Modified from https://github.com/TTimo/GtkRadiant/blob/1.6-release/makeversion.py

import sys, re, string, os, subprocess

version_file = 'VERSION'
header_file = 'src/core/include/core/version.h'

#
# read version data from root file
#
def get_version():
    f = open(version_file, 'r')

    data = f.read().strip()
    f.close()

    lines = data.split('\n')
    line = None
    for l in lines:
        l = l.strip()
        if l and not l.startswith('#'):
            line = l
            break

    if line is None:
        sys.stderr.write("Error: couldn't find version string\n")
        sys.exit(1)

    sys.stdout.write("File %s contains string: \"%s\"\n" % (version_file, line))

    # https://semver.org/#is-there-a-suggested-regular-expression-regex-to-check-a-semver-string
    exp = re.compile('^(0|[1-9]\\d*)\\.(0|[1-9]\\d*)\\.(0|[1-9]\\d*)(?:-((?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*)(?:\\.(?:0|[1-9]\\d*|\\d*[a-zA-Z-][0-9a-zA-Z-]*))*))?(?:\\+([0-9a-zA-Z-]+(?:\\.[0-9a-zA-Z-]+)*))?$')
    if exp.match(line) is None:
        sys.stderr.write("Error: invalid version string\n")
        sys.exit(1)

    (major, minor, patch, prerelease, buildmetadata) = exp.match(line).groups()
    sys.stdout.write("Parsed string as:\n  Major: %s\n  Minor: %s\n  Patch: %s\n  Prerelease: %s\n  Build Metadata: %s\n" % (major, minor, patch, prerelease, buildmetadata))

    return (major, minor, patch, prerelease, buildmetadata)

#
# get git info
#
def get_git_info():
    commithash = subprocess.check_output(['git', 'rev-parse', '--short', 'HEAD']).decode('utf-8').strip()
    sys.stdout.write("Git commit hash: %s\n" % commithash)

    branch = subprocess.check_output(['git', 'rev-parse', '--abbrev-ref', 'HEAD']).decode('utf-8').strip()
    sys.stdout.write("Git branch: %s\n" % branch)

    commits = subprocess.check_output(['git', 'rev-list', '--count', 'HEAD']).decode('utf-8').strip()
    sys.stdout.write("Git commits: %s\n" % commits)

    return (commithash, branch, commits)

#
# write version header
#
def make_version():
    (major, minor, patch, prerelease, buildmetadata) = get_version()
    (commithash, branch, commits) = get_git_info()

    f = open(header_file, 'w')

    f.write(
"""// SPDX-FileCopyrightText: 2023 thecheeseman
//
// SPDX-License-Identifier: GPL-3.0-or-later

#ifndef CORE_VERSION_H
#define CORE_VERSION_H

// ***** Autogenerated by tools/make_version.py *****
// ***** Do not edit this file directly! *****

namespace iocod {

""")

    f.write('inline constexpr int version_major = %d;\n' % int(major))
    f.write('inline constexpr int version_minor = %d;\n' % int(minor))
    f.write('inline constexpr int version_patch = %d;\n\n' % int(patch))

    f.write('// optional pre-release and build metadata, if any\n')
    if prerelease is not None:
        f.write('inline constexpr const char* version_prerelease = "%s";\n' % prerelease)
    else:
        f.write('//inline constexpr const char* version_prerelease = "";\n')
    if buildmetadata is not None:
        f.write('inline constexpr const char* version_build_metadata = "%s";\n\n' % buildmetadata)
    else:
        f.write('//inline constexpr const char* version_build_metadata = "";\n\n')

    f.write('// last git commit information, if built from git repo\n')
    if commithash is not None:
        f.write('inline constexpr const char* version_git_commit_hash = "%s";\n' % commithash)
    else:
        f.write('//inline constexpr const char* version_git_commit_hash = "";\n')
    if branch is not None:
        f.write('inline constexpr const char* version_git_branch = "%s";\n' % branch)
    else:
        f.write('//inline constexpr const char* version_git_branch = "";\n')

    if commits is not None:
        f.write('inline constexpr int version_git_commits = %s;\n\n' % int(commits))
    else:
        f.write('//inline constexpr int version_git_commits = 0;\n\n')

    f.write('// major.minor.patch\n')
    f.write('inline constexpr const char* version_string = "%s.%s.%s";\n\n' % (major, minor, patch))

    f.write('// major.minor.patch(-prerelease)(+buildmetadata)\n')
    if prerelease is not None:
        if buildmetadata is not None:
            f.write('inline constexpr const char* version_string_full = "%s.%s.%s-%s+%s";\n\n' % (major, minor, patch, prerelease, buildmetadata))
        else:
            f.write('inline constexpr const char* version_string_full = "%s.%s.%s-%s";\n\n' % (major, minor, patch, prerelease))
    else:
        f.write('inline constexpr const char* version_string_full = "%s.%s.%s";\n\n' % (major, minor, patch))

    f.write('// build commits (branch-commithash)\n')
    if commits is not None and commithash is not None and branch is not None:
        f.write('inline constexpr const char* version_build = "build %s (%s-%s)";\n\n' % (commits, branch, commithash))
    else:
        f.write('inline constexpr const char* version_build = "";\n\n')

    f.write(
"""// version encoding utilities
inline constexpr int version_major_multiplier = 1000000;
inline constexpr int version_minor_multiplier = 1000;

inline constexpr int VersionEncode(int major, int minor, int patch)
{
    return (major * version_major_multiplier) + (minor * version_minor_multiplier) + patch;
}

inline constexpr int VersionDecodeMajor(int version)
{
    return version / version_major_multiplier;
}

inline constexpr int VersionDecodeMinor(int version)
{
    return (version % version_major_multiplier) / version_minor_multiplier;
}

inline constexpr int VersionDecodePatch(int version)
{
    return version % version_minor_multiplier;
}

} // namespace iocod

// ***** Autogenerated by tools/make_version.py *****
// ***** Do not edit this file directly! *****

#endif // CORE_VERSION_H
""")

    f.close()

    sys.stdout.write('Wrote %s\n' % header_file)

#
# main
#
if __name__ == '__main__':
    cwd = os.path.dirname(os.path.realpath(__file__))
    if cwd.endswith('Tools'):
        os.chdir('..')

    make_version()
